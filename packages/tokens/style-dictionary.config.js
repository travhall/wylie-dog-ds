import StyleDictionary from 'style-dictionary';
import { writeFileSync } from 'fs';

// Custom format for Tailwind 4.x @theme directive
StyleDictionary.registerFormat({
  name: 'css/tailwind-theme',
  format: function(dictionary) {
    const colorTokens = [];
    const otherTokens = [];
    
    dictionary.allTokens.forEach(token => {
      const name = token.path.join('-');
      
      // Map color tokens to Tailwind utility format
      if (token.type === 'color') {
        if (token.path[0] === 'color') {
          // Convert color.blue.500 -> --color-blue-500
          colorTokens.push(`  --color-${token.path.slice(1).join('-')}: ${token.value};`);
        } else {
          // Keep other color tokens as-is for components
          otherTokens.push(`  --${name}: ${token.value};`);
        }
      } else {
        // Keep other tokens as-is
        otherTokens.push(`  --${name}: ${token.value};`);
      }
    });
    
    return `@theme {\n${[...colorTokens, ...otherTokens].join('\n')}\n}`;
  }
});

const sd = new StyleDictionary({
  source: ['src/**/*.json'],
  platforms: {
    css: {
      transformGroup: 'css',
      buildPath: 'dist/',
      files: [{
        destination: 'tokens.css',
        format: 'css/variables',
        selector: ':root'
      }]
    },
    tailwindTheme: {
      transformGroup: 'css',
      buildPath: 'dist/',
      files: [{
        destination: 'theme.css',
        format: 'css/tailwind-theme'
      }]
    },
    js: {
      transformGroup: 'js',
      buildPath: 'dist/',
      files: [{
        destination: 'tokens.js',
        format: 'javascript/module'
      }]
    },
    tailwind: {
      transformGroup: 'js',
      buildPath: 'dist/',
      files: [{
        destination: 'tailwind.js',
        format: 'javascript/module-flat'
      }]
    }
  }
});

// Build all platforms
await sd.buildAllPlatforms();

// Generate TypeScript file manually after build
const dictionary = await sd.exportPlatform('js');

function generateTypeScriptTokens(dictionary) {
  const colorSystem = {};
  const spacingScale = {};
  const shadowScale = {};
  
  dictionary.allTokens.forEach(token => {
    if (token.type === 'color' && token.path[0] === 'color') {
      const [, colorName, shade] = token.path;
      if (!colorSystem[colorName]) colorSystem[colorName] = {};
      colorSystem[colorName][shade] = token.value;
    } else if (token.type === 'spacing') {
      const key = token.path[token.path.length - 1];
      spacingScale[key] = token.value;
    } else if (token.type === 'boxShadow') {
      const key = token.path[token.path.length - 1];
      shadowScale[key] = token.value;
    }
  });
  
  return `// This file is generated by the build process
// DO NOT EDIT MANUALLY

export const colorSystem = ${JSON.stringify(colorSystem, null, 2)} as const;

export const spacingScale = ${JSON.stringify(spacingScale, null, 2)} as const;

export const shadowScale = ${JSON.stringify(shadowScale, null, 2)} as const;

export const flatTokens = {
  // Colors
  ...Object.entries(colorSystem).reduce((acc, [colorName, shades]) => {
    Object.entries(shades).forEach(([shade, value]) => {
      acc[\`color-\${colorName}-\${shade}\`] = value;
    });
    return acc;
  }, {} as Record<string, string>),
  
  // Spacing
  ...Object.entries(spacingScale).reduce((acc, [key, value]) => {
    acc[\`spacing-\${key}\`] = value;
    return acc;
  }, {} as Record<string, string>),
  
  // Shadows
  ...Object.entries(shadowScale).reduce((acc, [key, value]) => {
    acc[\`shadow-\${key}\`] = value;
    return acc;
  }, {} as Record<string, string>)
};

export const tokens = {
  color: colorSystem,
  spacing: spacingScale,
  shadow: shadowScale
};
`;
}

// Write the TypeScript file
const tsContent = generateTypeScriptTokens(dictionary);
writeFileSync('src/tokens.generated.ts', tsContent);

console.log('✅ Tokens built successfully');
console.log('✅ TypeScript tokens generated');