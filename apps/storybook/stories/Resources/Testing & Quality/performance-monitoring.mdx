import { Meta } from "@storybook/addon-docs/blocks";

<Meta title="Resources/Testing & Quality/Performance Monitoring" />

# Performance Monitoring Guide

Comprehensive guide for monitoring and measuring performance in production applications using the Wylie Dog Design System.

## Table of Contents

1. [Core Web Vitals](#core-web-vitals)
2. [Setting Up Monitoring](#setting-up-monitoring)
3. [Bundle Analysis](#bundle-analysis)
4. [Runtime Performance](#runtime-performance)
5. [Component Performance](#component-performance)
6. [Network Performance](#network-performance)
7. [Production Monitoring](#production-monitoring)

---

## Core Web Vitals

Google's Core Web Vitals are essential metrics for measuring user experience:

### Largest Contentful Paint (LCP)

**What it measures:** Loading performance - when the largest content element becomes visible
**Good:** ≤ 2.5 seconds
**Needs Improvement:** 2.5 - 4.0 seconds
**Poor:** > 4.0 seconds

**How to improve:**

- Optimize images (WebP, lazy loading, proper sizing)
- Use CDN for static assets
- Minimize render-blocking resources
- Implement server-side rendering (SSR)
- Preload critical resources

```html
<!-- Preload critical resources -->
<link rel="preload" as="image" href="/hero.webp" />
<link rel="preload" as="font" href="/fonts/primary.woff2" crossorigin />
```

### First Input Delay (FID)

**What it measures:** Interactivity - time from user interaction to browser response
**Good:** ≤ 100 milliseconds
**Needs Improvement:** 100 - 300 milliseconds
**Poor:** > 300 milliseconds

**How to improve:**

- Break up long JavaScript tasks
- Use code splitting
- Defer non-critical JavaScript
- Minimize main thread work
- Use web workers for heavy computations

```tsx
// Break up long tasks with setTimeout
function processLargeDataset(data) {
  const batchSize = 100;
  let index = 0;

  function processBatch() {
    const batch = data.slice(index, index + batchSize);
    // Process batch...

    index += batchSize;
    if (index < data.length) {
      setTimeout(processBatch, 0); // Yield to browser
    }
  }

  processBatch();
}
```

### Cumulative Layout Shift (CLS)

**What it measures:** Visual stability - unexpected layout shifts during loading
**Good:** ≤ 0.1
**Needs Improvement:** 0.1 - 0.25
**Poor:** > 0.25

**How to improve:**

- Set explicit width/height for images and embeds
- Reserve space for dynamic content
- Avoid inserting content above existing content
- Use CSS aspect-ratio for responsive images

```tsx
// Reserve space for images
<img
  src="/image.jpg"
  alt="Description"
  width="800"
  height="600"
  style={{ aspectRatio: "800/600" }}
/>

// Reserve space for dynamic content
<div style={{ minHeight: "300px" }}>
  {loading ? <Skeleton height={300} /> : <Content />}
</div>
```

---

## Setting Up Monitoring

### Web Vitals Library

Install and configure the web-vitals library:

```bash
npm install web-vitals
```

```tsx
// app/monitoring.ts
import { onCLS, onFID, onFCP, onLCP, onTTFB } from "web-vitals";

function sendToAnalytics(metric: Metric) {
  // Send to your analytics endpoint
  const body = JSON.stringify({
    name: metric.name,
    value: metric.value,
    id: metric.id,
    delta: metric.delta,
  });

  // Use `navigator.sendBeacon()` if available, falling back to `fetch()`
  if (navigator.sendBeacon) {
    navigator.sendBeacon("/analytics", body);
  } else {
    fetch("/analytics", { body, method: "POST", keepalive: true });
  }
}

// Measure and report all Web Vitals
onCLS(sendToAnalytics);
onFID(sendToAnalytics);
onFCP(sendToAnalytics);
onLCP(sendToAnalytics);
onTTFB(sendToAnalytics);
```

### Performance Observer API

Monitor specific performance metrics:

```tsx
// Monitor long tasks (tasks > 50ms)
const observer = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    console.log("Long task detected:", {
      duration: entry.duration,
      startTime: entry.startTime,
    });
  }
});

observer.observe({ entryTypes: ["longtask"] });

// Monitor resource timing
const resourceObserver = new PerformanceObserver((list) => {
  for (const entry of list.getEntries()) {
    if (entry.duration > 1000) {
      console.warn("Slow resource:", {
        name: entry.name,
        duration: entry.duration,
        size: entry.transferSize,
      });
    }
  }
});

resourceObserver.observe({ entryTypes: ["resource"] });
```

### Custom Performance Marks

Add custom timing marks:

```tsx
// Mark important moments
performance.mark("app-init-start");

// ... application initialization

performance.mark("app-init-end");

// Measure duration
performance.measure("app-init", "app-init-start", "app-init-end");

// Get measurements
const measurements = performance.getEntriesByType("measure");
console.log("App initialization:", measurements[0].duration, "ms");
```

---

## Bundle Analysis

### Analyzing Bundle Size

Use the built-in bundle analyzer:

```bash
# Build with bundle analysis
pnpm --filter storybook build:analyze

# View the interactive report
open apps/storybook/storybook-static/bundle-stats.html
```

### Understanding the Report

The bundle analyzer shows:

**Stat Size:** Uncompressed size (what's in node_modules)
**Parsed Size:** Minified size (what's in your bundle)
**Gzip Size:** Compressed size (what users download)

**Target sizes:**

- Main bundle: < 200 KB (gzipped)
- Vendor bundle: < 150 KB (gzipped)
- Total initial load: < 350 KB (gzipped)

### Bundle Size Budget

Configure performance budgets:

```json
// .size-limit.json
[
  {
    "name": "Main Bundle",
    "path": "dist/main.js",
    "limit": "200 KB"
  },
  {
    "name": "Vendor Bundle",
    "path": "dist/vendor.js",
    "limit": "150 KB"
  }
]
```

### Tracking Bundle Size Over Time

Monitor bundle size in CI/CD:

```yaml
# .github/workflows/bundle-size.yml
- name: Analyze bundle size
  run: |
    pnpm build:analyze
    npx size-limit

- name: Comment PR
  uses: andresz1/size-limit-action@v1
  with:
    github_token: ${{ secrets.GITHUB_TOKEN }}
```

---

## Runtime Performance

### React DevTools Profiler

Profile component render performance:

```tsx
import { Profiler, ProfilerOnRenderCallback } from "react";

const onRenderCallback: ProfilerOnRenderCallback = (
  id,
  phase,
  actualDuration,
  baseDuration,
  startTime,
  commitTime
) => {
  console.log({
    component: id,
    phase, // "mount" or "update"
    renderTime: actualDuration,
    potentialTime: baseDuration,
  });

  // Log slow renders
  if (actualDuration > 16) {
    // 16ms = 60fps threshold
    console.warn(`Slow render detected in ${id}: ${actualDuration}ms`);
  }
};

function App() {
  return (
    <Profiler id="App" onRender={onRenderCallback}>
      <YourComponents />
    </Profiler>
  );
}
```

### Chrome DevTools Performance Tab

**How to use:**

1. Open Chrome DevTools (F12)
2. Go to Performance tab
3. Click Record (or Ctrl+E)
4. Interact with your app
5. Stop recording
6. Analyze the flame chart

**What to look for:**

- **Long tasks** (yellow blocks > 50ms)
- **Layout thrashing** (purple blocks)
- **Excessive re-renders** (React Profiler)
- **Main thread blocking** (red triangles)

### Memory Profiling

Detect memory leaks:

```tsx
// Check for memory leaks in useEffect cleanup
useEffect(() => {
  const subscription = dataSource.subscribe();

  // Cleanup is critical!
  return () => {
    subscription.unsubscribe();
  };
}, []);

// Use heap snapshots in Chrome DevTools:
// 1. Memory tab → Take snapshot
// 2. Interact with app
// 3. Take another snapshot
// 4. Compare snapshots
// 5. Look for detached DOM nodes or growing objects
```

---

## Component Performance

### Measuring Component Render Time

```tsx
import { useEffect, useRef } from "react";

function useRenderTime(componentName: string) {
  const renderCount = useRef(0);
  const startTime = useRef(performance.now());

  useEffect(() => {
    renderCount.current += 1;
    const endTime = performance.now();
    const duration = endTime - startTime.current;

    console.log(`${componentName} render #${renderCount.current}: ${duration}ms`);

    startTime.current = performance.now();
  });
}

// Usage
function MyComponent() {
  useRenderTime("MyComponent");

  return <div>Content</div>;
}
```

### Detecting Unnecessary Re-renders

```tsx
import { useEffect, useRef } from "react";

function useWhyDidYouUpdate(name: string, props: Record<string, any>) {
  const previousProps = useRef<Record<string, any>>();

  useEffect(() => {
    if (previousProps.current) {
      const allKeys = Object.keys({ ...previousProps.current, ...props });
      const changedProps: Record<string, any> = {};

      allKeys.forEach((key) => {
        if (previousProps.current![key] !== props[key]) {
          changedProps[key] = {
            from: previousProps.current![key],
            to: props[key],
          };
        }
      });

      if (Object.keys(changedProps).length > 0) {
        console.log(`[${name}] Props changed:`, changedProps);
      }
    }

    previousProps.current = props;
  });
}

// Usage
function MyComponent(props) {
  useWhyDidYouUpdate("MyComponent", props);
  return <div>Content</div>;
}
```

---

## Network Performance

### Resource Timing API

Monitor network requests:

```tsx
function analyzeNetworkPerformance() {
  const resources = performance.getEntriesByType("resource");

  const slowResources = resources.filter((r) => r.duration > 1000);
  const largeResources = resources.filter((r) => r.transferSize > 500000);

  console.table(
    slowResources.map((r) => ({
      name: r.name,
      duration: `${r.duration.toFixed(2)}ms`,
      size: `${(r.transferSize / 1024).toFixed(2)}KB`,
    }))
  );
}

// Run after page load
window.addEventListener("load", () => {
  setTimeout(analyzeNetworkPerformance, 1000);
});
```

### Network Waterfall Analysis

**Look for:**

- **Chained requests** - Request A must complete before B starts
- **Large resources** - Files > 500 KB
- **Slow responses** - TTFB > 600ms
- **Unnecessary requests** - Duplicates or unused resources

**Solutions:**

```tsx
// Preload critical resources
<link rel="preload" href="/critical.css" as="style" />
<link rel="preload" href="/hero.webp" as="image" />

// Prefetch likely next pages
<link rel="prefetch" href="/about.js" />

// DNS prefetch for third-party domains
<link rel="dns-prefetch" href="https://api.example.com" />
```

---

## Production Monitoring

### Error Tracking with Sentry

```tsx
import * as Sentry from "@sentry/react";

Sentry.init({
  dsn: "your-sentry-dsn",
  integrations: [
    new Sentry.BrowserTracing(),
    new Sentry.Replay({
      maskAllText: false,
      blockAllMedia: false,
    }),
  ],
  tracesSampleRate: 0.1, // 10% of transactions
  replaysSessionSampleRate: 0.1,
  replaysOnErrorSampleRate: 1.0,
});

// Track custom performance metrics
Sentry.setMeasurement("component.load.time", 142, "millisecond");
```

### Real User Monitoring (RUM)

Track actual user performance:

```tsx
// Send performance data to your analytics
function reportWebVitals(metric: Metric) {
  // Example: Send to Google Analytics
  gtag("event", metric.name, {
    value: Math.round(metric.value),
    event_category: "Web Vitals",
    event_label: metric.id,
    non_interaction: true,
  });

  // Example: Send to custom endpoint
  fetch("/api/analytics", {
    method: "POST",
    body: JSON.stringify({
      metric: metric.name,
      value: metric.value,
      page: window.location.pathname,
      userAgent: navigator.userAgent,
    }),
  });
}
```

### Performance Alerts

Set up alerts for performance degradation:

```tsx
// Alert if LCP > 4 seconds
onLCP((metric) => {
  if (metric.value > 4000) {
    // Send alert
    fetch("/api/alerts", {
      method: "POST",
      body: JSON.stringify({
        type: "performance",
        severity: "high",
        message: `LCP exceeded threshold: ${metric.value}ms`,
        page: window.location.pathname,
      }),
    });
  }
});
```

### A/B Testing Performance Impact

Measure performance impact of changes:

```tsx
// Track performance by variant
function trackPerformanceVariant(variant: "A" | "B", metric: Metric) {
  analytics.track("performance", {
    variant,
    metric: metric.name,
    value: metric.value,
  });
}

// Compare performance between variants
onLCP((metric) => {
  const variant = getABTestVariant(); // Your A/B test logic
  trackPerformanceVariant(variant, metric);
});
```

---

## Performance Dashboard

Create a simple performance dashboard:

```tsx
import { useState, useEffect } from "react";
import { onCLS, onFID, onLCP } from "web-vitals";

function PerformanceDashboard() {
  const [metrics, setMetrics] = useState({
    lcp: null,
    fid: null,
    cls: null,
  });

  useEffect(() => {
    onLCP((metric) => setMetrics((m) => ({ ...m, lcp: metric.value })));
    onFID((metric) => setMetrics((m) => ({ ...m, fid: metric.value })));
    onCLS((metric) => setMetrics((m) => ({ ...m, cls: metric.value })));
  }, []);

  const getStatus = (value: number, thresholds: [number, number]) => {
    if (value <= thresholds[0]) return "good";
    if (value <= thresholds[1]) return "needs-improvement";
    return "poor";
  };

  return (
    <div className="performance-dashboard">
      <h2>Performance Metrics</h2>

      <div className="metric">
        <h3>LCP</h3>
        <p className={getStatus(metrics.lcp, [2500, 4000])}>
          {metrics.lcp ? `${metrics.lcp.toFixed(0)}ms` : "Measuring..."}
        </p>
      </div>

      <div className="metric">
        <h3>FID</h3>
        <p className={getStatus(metrics.fid, [100, 300])}>
          {metrics.fid ? `${metrics.fid.toFixed(0)}ms` : "Waiting for input..."}
        </p>
      </div>

      <div className="metric">
        <h3>CLS</h3>
        <p className={getStatus(metrics.cls, [0.1, 0.25])}>
          {metrics.cls ? metrics.cls.toFixed(3) : "Measuring..."}
        </p>
      </div>
    </div>
  );
}
```

---

## Performance Monitoring Checklist

**Setup** (One-time):

- [ ] Install web-vitals library
- [ ] Configure error tracking (Sentry/LogRocket)
- [ ] Set up bundle size monitoring
- [ ] Configure performance budgets
- [ ] Add bundle analyzer to build process

**Development**:

- [ ] Profile components with React DevTools
- [ ] Check bundle size before commits
- [ ] Run Lighthouse audits locally
- [ ] Monitor long tasks in DevTools
- [ ] Test on slow networks (throttling)

**CI/CD**:

- [ ] Run bundle size checks
- [ ] Run Lighthouse CI
- [ ] Track bundle size trends
- [ ] Alert on performance regressions

**Production**:

- [ ] Monitor Core Web Vitals
- [ ] Track error rates
- [ ] Monitor API response times
- [ ] Set up performance alerts
- [ ] Review metrics dashboard weekly

---

## Tools and Resources

**Analysis Tools**:

- [Chrome DevTools](https://developer.chrome.com/docs/devtools/)
- [Lighthouse](https://developers.google.com/web/tools/lighthouse)
- [WebPageTest](https://www.webpagetest.org/)
- [Bundlephobia](https://bundlephobia.com/)

**Monitoring Services**:

- [Sentry](https://sentry.io/) - Error tracking & performance
- [LogRocket](https://logrocket.com/) - Session replay & monitoring
- [Datadog RUM](https://www.datadoghq.com/product/real-user-monitoring/)
- [New Relic](https://newrelic.com/)

**Performance Libraries**:

- [web-vitals](https://github.com/GoogleChrome/web-vitals)
- [react-window](https://github.com/bvaughn/react-window) - Virtual lists
- [react-lazy-load](https://github.com/loktar00/react-lazy-load)

**Learning Resources**:

- [Web.dev Performance](https://web.dev/performance/)
- [Core Web Vitals](https://web.dev/vitals/)
- [React Performance](https://react.dev/learn/render-and-commit)
