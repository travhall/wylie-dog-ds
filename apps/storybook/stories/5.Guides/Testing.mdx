import { Meta } from '@storybook/addon-docs/blocks';

<Meta title="5. Guides/Testing" />

# Testing Guide

Learn how to write comprehensive tests for components using Vitest, Testing Library, and jest-axe for accessibility testing.

## ðŸŽ¯ Testing Philosophy

Our testing strategy focuses on:

1. **User Behavior** - Test how users interact with components, not implementation details
2. **Accessibility** - Ensure components work for everyone, including assistive technologies
3. **Visual Regression** - Catch unintended UI changes
4. **Type Safety** - Leverage TypeScript for compile-time safety

---

## ðŸ› ï¸ Testing Stack

### Core Libraries

- **Vitest** - Fast unit test framework
- **Testing Library** - User-centric testing utilities
- **jest-axe** - Automated accessibility testing
- **Playwright** - Browser-based component testing

### Configuration

```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/test-setup.ts'],
    globals: true,
    css: true,
    coverage: {
      provider: 'v8',
      thresholds: {
        statements: 80,
        branches: 70,
        functions: 80,
        lines: 80
      }
    }
  }
});
```

---

## ðŸ“ Writing Tests

### Basic Component Test

```typescript
import { render, screen } from '@testing-library/react';
import { Button } from '../button';

describe('Button', () => {
  it('renders with correct text', () => {
    render(<Button>Click me</Button>);

    const button = screen.getByRole('button', { name: /click me/i });
    expect(button).toBeInTheDocument();
  });

  it('calls onClick when clicked', async () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click me</Button>);

    const button = screen.getByRole('button', { name: /click me/i });
    await userEvent.click(button);

    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

**Key Points:**
- Use `getByRole` for semantic queries
- Test user interactions, not implementation
- Use descriptive test names

### Accessibility Testing

```typescript
import { axe, toHaveNoViolations } from 'jest-axe';

expect.extend(toHaveNoViolations);

describe('Button Accessibility', () => {
  it('should pass axe accessibility audit', async () => {
    const { container } = render(<Button>Click me</Button>);

    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('should be keyboard accessible', () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click me</Button>);

    const button = screen.getByRole('button');

    // Focus button
    button.focus();
    expect(button).toHaveFocus();

    // Activate with Enter
    fireEvent.keyDown(button, { key: 'Enter' });
    fireEvent.click(button);
    expect(handleClick).toHaveBeenCalled();

    // Activate with Space
    fireEvent.keyDown(button, { key: ' ' });
    expect(handleClick).toHaveBeenCalledTimes(2);
  });

  it('should handle disabled state correctly', async () => {
    const { container } = render(<Button disabled>Disabled</Button>);

    const button = screen.getByRole('button');
    expect(button).toBeDisabled();
    expect(button).toHaveAttribute('aria-disabled', 'true');

    // Should still pass a11y audit when disabled
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });
});
```

**Key Points:**
- Run axe on all component states
- Test keyboard navigation
- Verify ARIA attributes
- Ensure disabled states are accessible

### Form Component Testing

```typescript
describe('Input', () => {
  it('handles user input correctly', async () => {
    const handleChange = vi.fn();
    render(<Input onChange={handleChange} />);

    const input = screen.getByRole('textbox');
    await userEvent.type(input, 'Hello');

    expect(input).toHaveValue('Hello');
    expect(handleChange).toHaveBeenCalledTimes(5); // Once per character
  });

  it('shows error state', () => {
    render(
      <div>
        <Label htmlFor="email">Email</Label>
        <Input
          id="email"
          aria-invalid={true}
          aria-describedby="email-error"
        />
        <span id="email-error">Invalid email</span>
      </div>
    );

    const input = screen.getByRole('textbox', { name: /email/i });
    expect(input).toHaveAttribute('aria-invalid', 'true');
    expect(input).toHaveAccessibleDescription('Invalid email');
  });

  it('associates label correctly', () => {
    render(
      <>
        <Label htmlFor="username">Username</Label>
        <Input id="username" />
      </>
    );

    const input = screen.getByRole('textbox', { name: /username/i });
    expect(input).toBeInTheDocument();
  });
});
```

**Key Points:**
- Test form validation states
- Verify label associations
- Check error message connections
- Use accessible queries

### Dialog Testing

```typescript
describe('Dialog', () => {
  it('opens and closes correctly', async () => {
    render(
      <Dialog>
        <DialogTrigger>Open</DialogTrigger>
        <DialogContent>
          <DialogTitle>Dialog Title</DialogTitle>
          <DialogDescription>Dialog content</DialogDescription>
        </DialogContent>
      </Dialog>
    );

    // Initially closed
    expect(screen.queryByRole('dialog')).not.toBeInTheDocument();

    // Open dialog
    await userEvent.click(screen.getByRole('button', { name: /open/i }));
    expect(screen.getByRole('dialog')).toBeInTheDocument();

    // Close dialog
    await userEvent.keyboard('{Escape}');
    await waitFor(() => {
      expect(screen.queryByRole('dialog')).not.toBeInTheDocument();
    });
  });

  it('traps focus inside dialog', async () => {
    render(
      <Dialog defaultOpen>
        <DialogContent>
          <DialogTitle>Focus Trap</DialogTitle>
          <Input placeholder="First input" />
          <Input placeholder="Second input" />
          <DialogClose>Close</DialogClose>
        </DialogContent>
      </Dialog>
    );

    const firstInput = screen.getByPlaceholderText('First input');
    const secondInput = screen.getByPlaceholderText('Second input');
    const closeButton = screen.getByRole('button', { name: /close/i });

    // Tab through elements
    await userEvent.tab();
    expect(firstInput).toHaveFocus();

    await userEvent.tab();
    expect(secondInput).toHaveFocus();

    await userEvent.tab();
    expect(closeButton).toHaveFocus();

    // Tab should cycle back to first element
    await userEvent.tab();
    expect(firstInput).toHaveFocus();
  });
});
```

**Key Points:**
- Test open/close behavior
- Verify focus trap
- Check Escape key handling
- Test with keyboard navigation

### Select/Dropdown Testing

```typescript
describe('Select', () => {
  it('allows user to select an option', async () => {
    render(
      <Select>
        <SelectTrigger>
          <SelectValue placeholder="Select fruit" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="apple">Apple</SelectItem>
          <SelectItem value="banana">Banana</SelectItem>
          <SelectItem value="orange">Orange</SelectItem>
        </SelectContent>
      </Select>
    );

    const trigger = screen.getByRole('combobox');
    await userEvent.click(trigger);

    const option = screen.getByRole('option', { name: /banana/i });
    await userEvent.click(option);

    expect(trigger).toHaveTextContent('Banana');
  });

  it('supports keyboard navigation', async () => {
    render(
      <Select>
        <SelectTrigger>
          <SelectValue placeholder="Select" />
        </SelectTrigger>
        <SelectContent>
          <SelectItem value="1">Option 1</SelectItem>
          <SelectItem value="2">Option 2</SelectItem>
          <SelectItem value="3">Option 3</SelectItem>
        </SelectContent>
      </Select>
    );

    const trigger = screen.getByRole('combobox');

    // Open with Enter
    trigger.focus();
    await userEvent.keyboard('{Enter}');

    // Navigate with arrow keys
    await userEvent.keyboard('{ArrowDown}');
    await userEvent.keyboard('{ArrowDown}');
    await userEvent.keyboard('{Enter}');

    expect(trigger).toHaveTextContent('Option 2');
  });
});
```

**Key Points:**
- Test both mouse and keyboard interactions
- Verify ARIA roles (combobox, option)
- Check that selected value updates
- Test arrow key navigation

---

## ðŸ§ª Testing Patterns

### Testing Variants

```typescript
describe('Button Variants', () => {
  const variants = ['default', 'primary', 'secondary', 'outline', 'ghost'] as const;

  variants.forEach((variant) => {
    it(`renders ${variant} variant correctly`, async () => {
      const { container } = render(<Button variant={variant}>Button</Button>);

      const button = screen.getByRole('button');
      expect(button).toHaveClass(`btn-${variant}`);

      // Each variant should pass accessibility
      const results = await axe(container);
      expect(results).toHaveNoViolations();
    });
  });
});
```

### Testing Loading States

```typescript
describe('Button Loading State', () => {
  it('shows loading indicator and disables button', () => {
    render(<Button loading>Submit</Button>);

    const button = screen.getByRole('button');
    expect(button).toBeDisabled();
    expect(screen.getByText(/loading/i)).toBeInTheDocument();
  });

  it('prevents click during loading', async () => {
    const handleClick = vi.fn();
    render(<Button loading onClick={handleClick}>Submit</Button>);

    const button = screen.getByRole('button');
    await userEvent.click(button);

    expect(handleClick).not.toHaveBeenCalled();
  });
});
```

### Testing Error States

```typescript
describe('Form Error Handling', () => {
  it('displays error message', () => {
    const errorMessage = 'Email is required';

    render(
      <div>
        <Label htmlFor="email">Email</Label>
        <Input
          id="email"
          aria-invalid={true}
          aria-describedby="email-error"
        />
        <span id="email-error" role="alert">
          {errorMessage}
        </span>
      </div>
    );

    const input = screen.getByRole('textbox', { name: /email/i });
    const error = screen.getByRole('alert');

    expect(input).toHaveAttribute('aria-invalid', 'true');
    expect(input).toHaveAccessibleDescription(errorMessage);
    expect(error).toHaveTextContent(errorMessage);
  });
});
```

### Testing Dark Mode

```typescript
describe('Theme Switching', () => {
  it('applies dark mode styles', () => {
    const { container } = render(
      <div className="dark">
        <Button>Dark Mode Button</Button>
      </div>
    );

    expect(container.firstChild).toHaveClass('dark');
  });

  it('maintains accessibility in dark mode', async () => {
    const { container } = render(
      <div className="dark">
        <Card>
          <CardHeader>
            <CardTitle>Dark Card</CardTitle>
          </CardHeader>
          <CardContent>Content</CardContent>
        </Card>
      </div>
    );

    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });
});
```

---

## ðŸŽ¨ Visual Testing with Storybook

### Story-Based Tests with Play Functions

Storybook 10 supports **play functions** - automated interaction tests that run directly in Storybook. This lets you test component behavior visually while documenting interactions.

#### Basic Play Function

```typescript
import type { Meta, StoryObj } from '@storybook/react';
import { within, userEvent, expect } from 'storybook/test';
import { Button } from './button';

const meta: Meta<typeof Button> = {
  component: Button,
  tags: ['autodocs'],
};

export default meta;
type Story = StoryObj<typeof Button>;

export const Primary: Story = {
  args: {
    variant: 'primary',
    children: 'Click Me',
  },
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);

    // Find button using Testing Library queries
    const button = canvas.getByRole('button', { name: /click me/i });

    // Simulate user interaction
    await userEvent.click(button);

    // Verify behavior
    expect(button).toHaveFocus();
  },
};
```

**Key Features:**
- Runs automatically when you view the story
- Uses `@storybook/test` (built on Testing Library)
- Displays results in Storybook's Interactions panel
- Can be used for visual regression testing

#### Form Interaction Testing

```typescript
export const LoginForm: Story = {
  render: () => (
    <form>
      <Label htmlFor="email">Email</Label>
      <Input id="email" type="email" />

      <Label htmlFor="password">Password</Label>
      <Input id="password" type="password" />

      <Button type="submit">Sign In</Button>
    </form>
  ),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);

    // Fill out form
    const emailInput = canvas.getByLabelText(/email/i);
    await userEvent.type(emailInput, 'user@example.com');
    expect(emailInput).toHaveValue('user@example.com');

    const passwordInput = canvas.getByLabelText(/password/i);
    await userEvent.type(passwordInput, 'password123');
    expect(passwordInput).toHaveValue('password123');

    // Submit form
    const submitButton = canvas.getByRole('button', { name: /sign in/i });
    await userEvent.click(submitButton);
  },
};
```

#### Testing Dialog Interactions

```typescript
export const DeleteConfirmation: Story = {
  render: () => (
    <AlertDialog>
      <AlertDialogTrigger asChild>
        <Button variant="destructive">Delete Account</Button>
      </AlertDialogTrigger>
      <AlertDialogContent>
        <AlertDialogTitle>Are you absolutely sure?</AlertDialogTitle>
        <AlertDialogDescription>
          This action cannot be undone.
        </AlertDialogDescription>
        <AlertDialogFooter>
          <AlertDialogCancel>Cancel</AlertDialogCancel>
          <AlertDialogAction>Delete</AlertDialogAction>
        </AlertDialogFooter>
      </AlertDialogContent>
    </AlertDialog>
  ),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);

    // Dialog should be closed initially
    expect(canvas.queryByRole('alertdialog')).not.toBeInTheDocument();

    // Open dialog
    const trigger = canvas.getByRole('button', { name: /delete account/i });
    await userEvent.click(trigger);

    // Dialog should be visible
    const dialog = canvas.getByRole('alertdialog');
    expect(dialog).toBeInTheDocument();

    // Verify title and description
    expect(canvas.getByText(/are you absolutely sure/i)).toBeInTheDocument();
    expect(canvas.getByText(/this action cannot be undone/i)).toBeInTheDocument();

    // Test keyboard navigation
    await userEvent.keyboard('{Tab}'); // Focus Cancel button
    const cancelButton = canvas.getByRole('button', { name: /cancel/i });
    expect(cancelButton).toHaveFocus();

    // Test Escape key closes dialog
    await userEvent.keyboard('{Escape}');
    await sleep(300); // Wait for animation
    expect(canvas.queryByRole('alertdialog')).not.toBeInTheDocument();
  },
};

// Helper for animations
const sleep = (ms: number) => new Promise(resolve => setTimeout(resolve, ms));
```

#### Testing Dropdown Menus

```typescript
export const AccountMenu: Story = {
  render: () => (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="outline">My Account</Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent>
        <DropdownMenuItem>Profile</DropdownMenuItem>
        <DropdownMenuItem>Settings</DropdownMenuItem>
        <DropdownMenuSeparator />
        <DropdownMenuItem>Sign Out</DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  ),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);

    // Open menu
    const trigger = canvas.getByRole('button', { name: /my account/i });
    await userEvent.click(trigger);

    // Verify menu items are visible
    expect(canvas.getByRole('menuitem', { name: /profile/i })).toBeInTheDocument();
    expect(canvas.getByRole('menuitem', { name: /settings/i })).toBeInTheDocument();
    expect(canvas.getByRole('menuitem', { name: /sign out/i })).toBeInTheDocument();

    // Test keyboard navigation
    await userEvent.keyboard('{ArrowDown}'); // First item
    await userEvent.keyboard('{ArrowDown}'); // Second item

    const settingsItem = canvas.getByRole('menuitem', { name: /settings/i });
    expect(settingsItem).toHaveFocus();

    // Select item with Enter
    await userEvent.keyboard('{Enter}');
  },
};
```

#### Testing Tab Navigation

```typescript
export const SettingsTabs: Story = {
  render: () => (
    <Tabs defaultValue="account">
      <TabsList>
        <TabsTrigger value="account">Account</TabsTrigger>
        <TabsTrigger value="password">Password</TabsTrigger>
        <TabsTrigger value="notifications">Notifications</TabsTrigger>
      </TabsList>
      <TabsContent value="account">Account settings content</TabsContent>
      <TabsContent value="password">Password settings content</TabsContent>
      <TabsContent value="notifications">Notification preferences</TabsContent>
    </Tabs>
  ),
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement);

    // Verify initial tab is active
    const accountTab = canvas.getByRole('tab', { name: /account/i });
    expect(accountTab).toHaveAttribute('aria-selected', 'true');
    expect(canvas.getByText(/account settings content/i)).toBeVisible();

    // Switch to password tab
    const passwordTab = canvas.getByRole('tab', { name: /password/i });
    await userEvent.click(passwordTab);

    expect(passwordTab).toHaveAttribute('aria-selected', 'true');
    expect(canvas.getByText(/password settings content/i)).toBeVisible();

    // Test keyboard navigation (Arrow keys)
    accountTab.focus();
    await userEvent.keyboard('{ArrowRight}'); // Move to next tab
    expect(passwordTab).toHaveFocus();

    await userEvent.keyboard('{ArrowRight}'); // Move to notifications tab
    const notificationsTab = canvas.getByRole('tab', { name: /notifications/i });
    expect(notificationsTab).toHaveFocus();
  },
};
```

### Running Play Functions

Play functions execute automatically when:
1. You navigate to a story in Storybook
2. You run Storybook's test runner (`test-storybook`)
3. Visual regression tests are performed

View results in the **Interactions** panel at the bottom of Storybook.

---

## ðŸ”„ Portable Stories Pattern

Storybook 10 introduces **portable stories** - the ability to reuse your stories as test cases in Vitest, Jest, or other test runners. This eliminates duplication between stories and tests.

### Why Portable Stories?

**Benefits:**
- âœ… **Single source of truth** - Write once, test everywhere
- âœ… **Reduce duplication** - No need to recreate component setups in tests
- âœ… **Better coverage** - Automatically test all story variants
- âœ… **Faster development** - Stories double as test cases

### Setup for Vitest

Configure Storybook for portable stories in your test setup:

```typescript
// vitest.setup.ts
import { setProjectAnnotations } from '@storybook/react';
import * as projectAnnotations from './.storybook/preview';

// Apply Storybook's global config (decorators, parameters) to tests
setProjectAnnotations(projectAnnotations);
```

```typescript
// vitest.config.ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./vitest.setup.ts'], // Load Storybook config
    globals: true,
  },
});
```

### Using Stories in Tests

#### Basic Example

```typescript
// button.test.tsx
import { render, screen } from '@testing-library/react';
import { composeStories } from '@storybook/react';
import * as stories from './button.stories';

// Convert all stories into renderable components
const { Primary, Secondary, Disabled } = composeStories(stories);

describe('Button Component', () => {
  it('renders primary button correctly', () => {
    render(<Primary />);

    const button = screen.getByRole('button');
    expect(button).toBeInTheDocument();
    expect(button).toHaveTextContent('Primary Button');
  });

  it('renders disabled button correctly', () => {
    render(<Disabled />);

    const button = screen.getByRole('button');
    expect(button).toBeDisabled();
  });

  it('passes accessibility audit for all variants', async () => {
    const variants = [Primary, Secondary, Disabled];

    for (const Story of variants) {
      const { container } = render(<Story />);
      const results = await axe(container);
      expect(results).toHaveNoViolations();
    }
  });
});
```

**Key Benefits:**
- Stories include all args, decorators, and parameters
- Automatic application of global Storybook configuration
- Test multiple variants without duplicating setup code

#### Testing All Story Variants

```typescript
// Automatically test all stories from a file
import { composeStories } from '@storybook/react';
import * as stories from './alert.stories';

const composedStories = composeStories(stories);

describe('Alert Component - All Variants', () => {
  // Get all story names
  const storyNames = Object.keys(composedStories);

  storyNames.forEach((storyName) => {
    it(`renders ${storyName} story correctly`, () => {
      const Story = composedStories[storyName];
      render(<Story />);

      // Basic smoke test - component renders without errors
      expect(screen.getByRole('alert')).toBeInTheDocument();
    });

    it(`${storyName} passes accessibility audit`, async () => {
      const Story = composedStories[storyName];
      const { container } = render(<Story />);

      const results = await axe(container);
      expect(results).toHaveNoViolations();
    });
  });
});
```

#### Advanced: Testing with Play Functions

If your stories have play functions, you can run them in your tests:

```typescript
import { composeStories } from '@storybook/react';
import * as stories from './dialog.stories';

const { DeleteConfirmation } = composeStories(stories);

describe('Dialog with Interactions', () => {
  it('runs story play function', async () => {
    const { container } = render(<DeleteConfirmation />);

    // Execute the story's play function
    if (DeleteConfirmation.play) {
      await DeleteConfirmation.play({
        canvasElement: container,
        // Additional context as needed
      });
    }

    // Story's interactions have run, verify final state
    expect(screen.queryByRole('alertdialog')).not.toBeInTheDocument();
  });
});
```

#### Form Testing with Stories

```typescript
// form-compositions.stories.tsx - Define story
export const ContactForm: Story = {
  render: () => (
    <form data-testid="contact-form">
      <Label htmlFor="name">Name</Label>
      <Input id="name" required />

      <Label htmlFor="email">Email</Label>
      <Input id="email" type="email" required />

      <Label htmlFor="message">Message</Label>
      <Textarea id="message" required />

      <Button type="submit">Send Message</Button>
    </form>
  ),
};

// form-compositions.test.tsx - Use story in test
import { composeStories } from '@storybook/react';
import * as stories from './form-compositions.stories';

const { ContactForm } = composeStories(stories);

describe('Contact Form Submission', () => {
  it('submits form with valid data', async () => {
    const handleSubmit = vi.fn((e) => e.preventDefault());

    const { container } = render(<ContactForm />);
    const form = container.querySelector('[data-testid="contact-form"]');
    form?.addEventListener('submit', handleSubmit);

    // Fill out form using the story's structure
    await userEvent.type(screen.getByLabelText(/name/i), 'John Doe');
    await userEvent.type(screen.getByLabelText(/email/i), 'john@example.com');
    await userEvent.type(screen.getByLabelText(/message/i), 'Hello world');

    // Submit
    await userEvent.click(screen.getByRole('button', { name: /send message/i }));

    expect(handleSubmit).toHaveBeenCalledTimes(1);
  });
});
```

### Best Practices

**DO:**
- âœ… Use `composeStories` to leverage all Storybook configuration
- âœ… Test all story variants for comprehensive coverage
- âœ… Run accessibility tests on composed stories
- âœ… Use stories as the base for complex integration tests

**DON'T:**
- âŒ Duplicate story args in test files - use composed stories
- âŒ Skip testing story variants - loop through all of them
- âŒ Forget to call `setProjectAnnotations` in test setup
- âŒ Mix story-based and manual component rendering in the same test file

### Common Patterns

#### Snapshot Testing

```typescript
import { composeStories } from '@storybook/react';
import * as stories from './badge.stories';

const composedStories = composeStories(stories);

describe('Badge Snapshots', () => {
  Object.keys(composedStories).forEach((storyName) => {
    it(`matches snapshot for ${storyName}`, () => {
      const Story = composedStories[storyName];
      const { container } = render(<Story />);
      expect(container.firstChild).toMatchSnapshot();
    });
  });
});
```

#### Interaction Testing

```typescript
import { composeStories } from '@storybook/react';
import * as stories from './select.stories';

const { Default } = composeStories(stories);

describe('Select Interactions', () => {
  it('allows selection via keyboard', async () => {
    render(<Default />);

    const trigger = screen.getByRole('combobox');

    // Use story's configuration, add custom interactions
    trigger.focus();
    await userEvent.keyboard('{Enter}');
    await userEvent.keyboard('{ArrowDown}');
    await userEvent.keyboard('{Enter}');

    expect(trigger).toHaveTextContent('Option 1');
  });
});
```

### Accessibility Testing in Stories

```typescript
// .storybook/preview.tsx
import { withTests } from '@storybook/addon-jest';
import results from '../.jest-test-results.json';

export const decorators = [withTests({ results })];

// Run axe on all stories
export const parameters = {
  a11y: {
    config: {
      rules: [
        {
          id: 'color-contrast',
          enabled: true,
        },
      ],
    },
  },
};
```

---

## ðŸ“Š Coverage Goals

### Target Metrics

- **Statements**: 80%+
- **Branches**: 70%+
- **Functions**: 80%+
- **Lines**: 80%+

### Running Coverage

```bash
# Full coverage report
pnpm test:coverage

# Coverage for specific component
pnpm test:coverage -- button

# Watch mode with coverage
pnpm test:watch --coverage
```

### Viewing Reports

```bash
# Generate HTML report
pnpm test:coverage

# Open in browser
open coverage/index.html
```

---

## ðŸš€ Running Tests

### Commands

```bash
# Run all tests
pnpm test

# Watch mode (re-run on changes)
pnpm test:watch

# Run specific test file
pnpm test button.test.tsx

# Run accessibility tests only
pnpm test a11y

# Run tests with coverage
pnpm test:coverage

# Update snapshots
pnpm test -u
```

### CI/CD Integration

```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Node
        uses: actions/setup-node@v3
        with:
          node-version: 18

      - name: Install pnpm
        uses: pnpm/action-setup@v2

      - name: Install dependencies
        run: pnpm install

      - name: Run tests
        run: pnpm test:coverage

      - name: Upload coverage
        uses: codecov/codecov-action@v3
```

---

## ðŸ’¡ Best Practices

### DO:

âœ… **Test user behavior, not implementation**
```typescript
// Good: Test what user sees
expect(screen.getByText('Hello')).toBeInTheDocument();

// Bad: Test implementation details
expect(component.state.text).toBe('Hello');
```

âœ… **Use semantic queries**
```typescript
// Good: Query by role
screen.getByRole('button', { name: /submit/i });

// Avoid: Query by class or test ID
screen.getByTestId('submit-button');
```

âœ… **Test accessibility for all states**
```typescript
const { container } = render(<Button disabled>Disabled</Button>);
const results = await axe(container);
expect(results).toHaveNoViolations();
```

âœ… **Use userEvent over fireEvent**
```typescript
// Good: Simulates real user interactions
await userEvent.click(button);
await userEvent.type(input, 'Hello');

// Avoid: Lower-level events
fireEvent.click(button);
```

### DON'T:

âŒ **Don't test styling details**
```typescript
// Bad: Brittle, tests implementation
expect(button).toHaveStyle({ backgroundColor: '#0000ff' });

// Good: Test functional behavior
expect(button).toHaveClass('btn-primary');
```

âŒ **Don't test third-party libraries**
```typescript
// Bad: Testing Radix UI internals
expect(dialog.portal).toRender();

// Good: Test your component's behavior
expect(screen.getByRole('dialog')).toBeInTheDocument();
```

âŒ **Don't forget to clean up**
```typescript
// Bad: Can cause memory leaks
afterEach(() => {
  // Nothing
});

// Good: Cleanup after each test
afterEach(() => {
  cleanup();
});
```

---

## ðŸ” Debugging Tests

### Using screen.debug()

```typescript
it('debugs component output', () => {
  render(<Button>Click me</Button>);

  // Print DOM to console
  screen.debug();

  // Print specific element
  screen.debug(screen.getByRole('button'));
});
```

### Testing Playground

```typescript
import { screen } from '@testing-library/react';

it('helps find queries', () => {
  render(<Button>Click me</Button>);

  // Opens interactive query builder in browser
  screen.logTestingPlaygroundURL();
});
```

### Checking Accessible Roles

```typescript
// List all accessible roles in rendered output
screen.logRoles();
```

---

## ðŸ“š Additional Resources

- [Testing Library Docs](https://testing-library.com/docs/react-testing-library/intro/)
- [jest-axe Documentation](https://github.com/nickcolley/jest-axe)
- [Vitest Documentation](https://vitest.dev/)
- [Accessibility Guide](/story/5-guides-accessibility--docs)
- [ARIA Practices](https://www.w3.org/WAI/ARIA/apg/)

---

## ðŸ†˜ Common Issues

### Issue: "Unable to find role"

**Problem:** Query fails to find element by role
**Solution:** Use `screen.logRoles()` to see available roles

```typescript
render(<Button>Click</Button>);
screen.logRoles(); // Shows all roles in output
```

### Issue: Async test failures

**Problem:** Tests fail intermittently with async operations
**Solution:** Use `waitFor` and `findBy` queries

```typescript
// Good: Wait for element
const button = await screen.findByRole('button');

// Also good: Wait for assertion
await waitFor(() => {
  expect(screen.getByText('Success')).toBeInTheDocument();
});
```

### Issue: Focus management tests fail

**Problem:** Focus-related tests don't work
**Solution:** Ensure jsdom environment and proper cleanup

```typescript
// vitest.config.ts
export default defineConfig({
  test: {
    environment: 'jsdom', // Required for focus
  },
});
```

---

Ready to write tests? Check out existing test files in `src/__tests__/` for more examples and patterns used throughout the design system.
