// Variable registry for tracking token name to Figma variable ID mappings

export interface TokenReference {
  originalValue: string;        // "{color.gray.50}"
  referencePath: string;        // "color.gray.50"
  figmaVariableName: string;    // "color/gray/50"
}

export class VariableRegistry {
  private tokenToVariableMap = new Map<string, string>(); // tokenName → variableId
  private pendingReferences = new Map<string, TokenReference[]>(); // variableId → references
  
  /**
   * Register a token name to variable ID mapping
   */
  register(tokenName: string, variableId: string): void {
    this.tokenToVariableMap.set(tokenName, variableId);
    console.log(`Registry: ${tokenName} → ${variableId}`);
  }
  
  /**
   * Resolve a token reference to a variable ID
   */
  resolve(tokenReference: string): string | null {
    // Extract token name from reference format
    const tokenName = this.extractTokenName(tokenReference);
    const variableId = this.tokenToVariableMap.get(tokenName);
    
    if (variableId) {
      console.log(`Resolved reference: ${tokenReference} → ${variableId}`);
      return variableId;
    }
    
    console.warn(`Unresolved reference: ${tokenReference} (token: ${tokenName})`);
    return null;
  }
  
  /**
   * Add pending reference for later resolution
   */
  addPendingReference(variableId: string, reference: TokenReference): void {
    if (!this.pendingReferences.has(variableId)) {
      this.pendingReferences.set(variableId, []);
    }
    this.pendingReferences.get(variableId)!.push(reference);
  }
  
  /**
   * Get all pending references for a variable
   */
  getPendingReferences(variableId: string): TokenReference[] {
    return this.pendingReferences.get(variableId) || [];
  }
  
  /**
   * Get all unresolved references
   */
  getUnresolvedReferences(): string[] {
    const unresolved: string[] = [];
    
    for (const [variableId, references] of Array.from(this.pendingReferences)) {
      for (const ref of references) {
        if (!this.resolve(ref.originalValue)) {
          unresolved.push(ref.originalValue);
        }
      }
    }
    
    return unresolved;
  }
  
  /**
   * Extract token name from reference format
   */
  private extractTokenName(reference: string): string {
    // Remove curly braces and return token name
    return reference.replace(/[{}]/g, '');
  }
  
  /**
   * Check if a value is a token reference
   */
  static isReference(value: any): boolean {
    return typeof value === 'string' && value.startsWith('{') && value.endsWith('}');
  }
  
  /**
   * Parse a token reference into structured data
   */
  static parseReference(reference: string): TokenReference {
    const referencePath = reference.replace(/[{}]/g, '');
    const figmaVariableName = referencePath.replace(/\./g, '/');
    
    return {
      originalValue: reference,
      referencePath,
      figmaVariableName
    };
  }
  
  /**
   * Clear all mappings and pending references
   */
  clear(): void {
    this.tokenToVariableMap.clear();
    this.pendingReferences.clear();
  }
  
  /**
   * Get registry stats for debugging
   */
  getStats(): { registered: number; pending: number } {
    const pending = Array.from(this.pendingReferences.values()).reduce(
      (sum, refs) => sum + refs.length, 0
    );
    
    return {
      registered: this.tokenToVariableMap.size,
      pending
    };
  }
}
